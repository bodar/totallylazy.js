import { Transducer } from "./transducers";
export declare type Mapper<A, B> = (a: A) => B;
export declare type Comparator<A> = (a: A, b: A) => number;
export declare function ascending<T>(a: T, b: T): 1 | 0 | -1;
export declare function descending<T>(a: T, b: T): number;
export declare function comparators<T>(...comparators: Comparator<T>[]): Comparator<T>;
export interface Key<A, K extends keyof A> extends Mapper<A, A[K]> {
    name: K;
}
export declare function key<A, K extends keyof A>(name: K): Key<A, K>;
export declare function value<A, K extends keyof A>(name: K): Mapper<A, A[K]>;
export declare type Reducer<A, B> = (accumulator: B, value: A) => B;
export declare function isIterable(instance: any): instance is Iterable<any>;
export declare function isAsyncIterable(instance: any): instance is AsyncIterable<any>;
export declare function isPromiseLike(instance: any): instance is PromiseLike<any>;
export declare function toIterable<T>(...t: T[]): Iterable<T>;
export declare function iterable<T>(values: ArrayLike<T>): Iterable<T>;
export declare function asyncIterable<T>(values: Array<Promise<T> | T> | Iterable<Promise<T> | T>): AsyncIterable<T>;
export declare function isArrayLike(value: any): value is ArrayLike<any>;
export declare type IterableLike<T> = Iterable<T> | ArrayLike<T>;
export declare function array<A>(iterable: IterableLike<A>): Array<A>;
export declare function array<A, B>(a: IterableLike<A>, b: Transducer<A, B>): Array<B>;
export declare function array<A, B, C>(a: IterableLike<A>, b: Transducer<A, B>, c: Transducer<B, C>): Array<C>;
export declare function array<A, B, C, D>(a: IterableLike<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>): Array<D>;
export declare function array<A, B, C, D, E>(a: IterableLike<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>): Array<E>;
export declare function array<A, B, C, D, E, F>(a: IterableLike<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>, f: Transducer<E, F>): Array<F>;
export declare function array<A>(iterable: AsyncIterable<A>): Promise<Array<A>>;
export declare function array<A, B>(a: AsyncIterable<A>, b: Transducer<A, B>): Promise<Array<B>>;
export declare function array<A, B, C>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>): Promise<Array<C>>;
export declare function array<A, B, C, D>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>): Promise<Array<D>>;
export declare function array<A, B, C, D, E>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>): Promise<Array<E>>;
export declare function array<A, B, C, D, E, F>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>, f: Transducer<E, F>): Promise<Array<F>>;
export declare function toAsyncIterable<A>(promise: PromiseLike<A>): AsyncIterable<A>;
export declare function by<A, K extends keyof A>(key: K, comparator?: Comparator<A[K]>): Comparator<A>;
export declare function by<A, K>(mapper: Mapper<A, K>, comparator?: Comparator<K>): Comparator<A>;
export declare function single<A>(iterable: Iterable<A>): A;
export declare function single<A, B>(a: Iterable<A>, b: Transducer<A, B>): B;
export declare function single<A, B, C>(a: Iterable<A>, b: Transducer<A, B>, c: Transducer<B, C>): C;
export declare function single<A, B, C, D>(a: Iterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>): D;
export declare function single<A, B, C, D, E>(a: Iterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>): E;
export declare function single<A, B, C, D, E, F>(a: Iterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>, f: Transducer<E, F>): F;
export declare function single<A>(iterable: AsyncIterable<A>): Promise<A>;
export declare function single<A, B>(a: AsyncIterable<A>, b: Transducer<A, B>): Promise<B>;
export declare function single<A, B, C>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>): Promise<C>;
export declare function single<A, B, C, D>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>): Promise<D>;
export declare function single<A, B, C, D, E>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>): Promise<E>;
export declare function single<A, B, C, D, E, F>(a: AsyncIterable<A>, b: Transducer<A, B>, c: Transducer<B, C>, d: Transducer<C, D>, e: Transducer<D, E>, f: Transducer<E, F>): Promise<F>;
export declare class AsyncIteratorHandler<T> implements AsyncIterableIterator<T> {
    private handlers;
    private state;
    value(value: T): void;
    error(value: Error): void;
    close(): void;
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    next(): Promise<IteratorResult<T>>;
    private newState;
    private newHandler;
    private consume;
}
